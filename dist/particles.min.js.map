{"version":3,"sources":["particles.min.js","/source/particles.js","/source/src/particles.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","Particles","this","element","canvas","document","createElement","width","offsetWidth","height","offsetHeight","ctx","getContext","particles","getParticles","fillCanvasSquare","value","Particle","x","y","resolution","font","getComputedStyle","getPropertyValue","fillStyle","fillText","innerHTML","data","getImageData","buffer32","Uint32Array","buffer","push","_this","clearRect","forEach","p","fillRect","appendChild","_this2","beginPath","arc","Math","PI","closePath","fill","_particles"],"mappings":"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","file":"particles.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Particles = factory()\n}(this, function () { 'use strict';\n\n  class Particles {\n\n    constructor(element) {\n\n      this.element = element;\n      this.canvas = document.createElement('canvas');\n      this.canvas.width = element.offsetWidth;\n      this.canvas.height = element.offsetHeight * 2;\n      this.ctx = this.canvas.getContext('2d');\n\n      const particles = this.getParticles(element);\n      this.fillCanvasSquare(particles);\n    }\n\n    getParticles() {\n      const resolution = 5;\n\n      function Particle(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n\n      // fill with text\n      this.ctx.font = getComputedStyle(this.element).getPropertyValue('font');\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillText(this.element.innerHTML, 10, this.element.offsetHeight);\n\n      // now parse bitmap based on grid\n      const data = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height).data;\n\n      // use a 32-bit buffer as we are only checking if a pixel is set or not\n      const buffer32 = new Uint32Array(data.buffer);\n\n      // using two loops here, single loop with index-to-x/y is also an option\n      const particles = [];\n      for (let y = 0; y < this.canvas.height; y += resolution) {\n        for (let x = 0; x < this.canvas.width; x += resolution) {\n\n          //buffer32[] will have a value > 0 (true) if set, if not 0=false\n          if (buffer32[y * this.canvas.width + x]) {\n            particles.push(new Particle(x, y));\n          }\n        }\n      }\n\n      return particles;\n    }\n\n    fillCanvasSquare(particles) {\n\n      // render particles\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      particles.forEach(p =>\n        this.ctx.fillRect(p.x - 2, p.y - 2, 3, 3) // just squares here\n      );\n\n      this.element.appendChild(this.canvas);\n    }\n\n    fillCanvasCircle(particles) {\n\n      // render particles\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      particles.forEach(p => {\n        this.ctx.beginPath();\n        this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);\n        this.ctx.closePath();\n        this.ctx.fill();\n      });\n\n      this.element.appendChild(this.canvas);\n    }\n\n    drawGrid() {\n      let width = this.canvas.width;\n      let height = this.canvas.height;\n\n      ctx.fillStyle = 'red';\n      for (let y = 0; y < height; y += resolution) {\n        ctx.fillRect(0, y - 0.5, width, 1);\n        for (let x = 0; x < width; x += resolution) {\n          ctx.fillRect(x - 0.5, 0, 1, height);\n        }\n      }\n    }\n\n  };\n\n  var _particles = Particles;\n\n  return _particles;\n\n}));\n","class Particles {\n\n  constructor(element) {\n\n    this.element = element;\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = element.offsetWidth;\n    this.canvas.height = element.offsetHeight * 2;\n    this.ctx = this.canvas.getContext('2d');\n\n    const particles = this.getParticles(element);\n    this.fillCanvasSquare(particles);\n  }\n\n  getParticles() {\n    const resolution = 5;\n\n    function Particle(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    // fill with text\n    this.ctx.font = getComputedStyle(this.element).getPropertyValue('font');\n    this.ctx.fillStyle = 'white';\n    this.ctx.fillText(this.element.innerHTML, 10, this.element.offsetHeight);\n\n    // now parse bitmap based on grid\n    const data = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height).data;\n\n    // use a 32-bit buffer as we are only checking if a pixel is set or not\n    const buffer32 = new Uint32Array(data.buffer);\n\n    // using two loops here, single loop with index-to-x/y is also an option\n    const particles = [];\n    for (let y = 0; y < this.canvas.height; y += resolution) {\n      for (let x = 0; x < this.canvas.width; x += resolution) {\n\n        //buffer32[] will have a value > 0 (true) if set, if not 0=false\n        if (buffer32[y * this.canvas.width + x]) {\n          particles.push(new Particle(x, y));\n        }\n      }\n    }\n\n    return particles;\n  }\n\n  fillCanvasSquare(particles) {\n\n    // render particles\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    particles.forEach(p =>\n      this.ctx.fillRect(p.x - 2, p.y - 2, 3, 3) // just squares here\n    );\n\n    this.element.appendChild(this.canvas);\n  }\n\n  fillCanvasCircle(particles) {\n\n    // render particles\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    particles.forEach(p => {\n      this.ctx.beginPath();\n      this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);\n      this.ctx.closePath();\n      this.ctx.fill();\n    });\n\n    this.element.appendChild(this.canvas);\n  }\n\n  drawGrid() {\n    let width = this.canvas.width;\n    let height = this.canvas.height;\n\n    ctx.fillStyle = 'red';\n    for (let y = 0; y < height; y += resolution) {\n      ctx.fillRect(0, y - 0.5, width, 1);\n      for (let x = 0; x < width; x += resolution) {\n        ctx.fillRect(x - 0.5, 0, 1, height);\n      }\n    }\n  }\n\n};\n\nexport default Particles;\n"],"sourceRoot":"/source/"}